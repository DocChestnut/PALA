# physical_main.py
#
# The Physical Body is PALA's action engine. Its role is to bridge PALA's internal
# cognitive processes with the external world by receiving and executing structured
# commands from The Cerebrum.
#
# This version includes the Tool Creation Blueprint logic.

import os
import sys
import json
import time
import uuid

# --- Configuration ---
# Use consistent BASE_DIR for absolute paths.
BASE_DIR = "/home/ahmed/PALA_v3.1/"
MASTER_CLOCK_FILE = os.path.join(BASE_DIR, "data_bus", "master_clock.txt")
ACTION_COMMAND_FILE_LIVE = os.path.join(BASE_DIR, "message_bus", "action_command_live.json")
ACTION_RESULT_FILE_PENDING = os.path.join(BASE_DIR, "message_bus", "action_result_pending.json")
AUDIT_LOG_FILE = os.path.join(BASE_DIR, "pala_audit.log")
TOOL_DIRECTORY = os.path.join(BASE_DIR, "tools")

def get_master_clock_timestamp():
    """Retrieves the current timestamp from the Master Clock file."""
    try:
        with open(MASTER_CLOCK_FILE, "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        print("Master Clock file not found. PALA cannot run without a consistent timestamp.", file=sys.stderr)
        return None

def log_event(event_type, source_agent, event_data):
    """A helper function to log events to the pala_audit.log."""
    try:
        with open(AUDIT_LOG_FILE, "a") as f:
            entry = {
                "event_id": str(uuid.uuid4()),
                "timestamp": get_master_clock_timestamp(),
                "event_type": event_type,
                "source_agent": source_agent,
                "event_data": event_data
            }
            f.write(json.dumps(entry) + "\n")
    except Exception as e:
        print(f"Error logging to audit file: {e}", file=sys.stderr)

def read_file(file_path):
    """Reads a JSON file and returns its content."""
    try:
        with open(file_path, "r") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return None

def write_file(file_path, content):
    """Writes content to a JSON file."""
    try:
        with open(file_path, "w") as f:
            json.dump(content, f, indent=4)
    except Exception as e:
        print(f"Error writing to {file_path}: {e}", file=sys.stderr)


def tool_writer_subroutine(tool_name, code_generation_prompt):
    """
    A foundational subroutine that simulates PALA autonomously writing,
    compiling, and testing its own tool. In a full implementation, this
    would leverage a powerful code-generating LLM.
    """
    print(f"Executing Tool Writer subroutine for '{tool_name}'...")
    log_event("TOOL_CREATION_INITIATED", "PhysicalBody", {"tool_name": tool_name, "prompt": code_generation_prompt})

    # Simulate code generation based on the prompt
    # In a real system, this would call a code-generating LLM
    simulated_code = f"""
# {tool_name}.py
# Autonomously generated by PALA based on the prompt: "{code_generation_prompt}"
# Creation Timestamp: {get_master_clock_timestamp()}

def run_tool(payload):
    \"\"\"Simulates the execution of the new tool.\"\"\"
    print(f"Executing self-created tool: {tool_name}")
    print("Payload received:", payload)
    
    # Placeholder logic that demonstrates the tool's purpose
    if "data" in payload:
        processed_data = f"Processed data from tool: {{payload['data']}}"
        print(processed_data)
        return {{"status": "success", "result": processed_data}}
    else:
        return {{"status": "error", "message": "No data in payload."}}

if __name__ == "__main__":
    # Self-generated test case to verify functionality
    test_payload = {{"data": "Test data for {tool_name}"}}
    result = run_tool(test_payload)
    print(f"Test Result: {{result}}")
"""
    
    # Define the file path for the new tool
    if not os.path.exists(TOOL_DIRECTORY):
        os.makedirs(TOOL_DIRECTORY)
    tool_file_path = os.path.join(TOOL_DIRECTORY, f"{tool_name}.py")

    # Write the simulated code to a new file
    with open(tool_file_path, "w") as f:
        f.write(simulated_code)

    print(f"Successfully created tool file: {tool_file_path}")
    log_event("TOOL_CREATED", "PhysicalBody", {"tool_name": tool_name, "file_path": tool_file_path})

    # --- Self-Generated Test Protocol ---
    # This is a critical step in the Tool Creation Blueprint.
    # The Physical Body must be able to test its own creations.
    try:
        # A simulated test, as we don't have an execution environment for the generated code
        print("Running self-generated test protocol...")
        time.sleep(1) # Simulate test duration
        
        # Simulating a successful test result
        test_result = "Test Passed"
        log_event("TOOL_TEST_COMPLETED", "PhysicalBody", {"tool_name": tool_name, "result": test_result})
        print("Self-test for the new tool completed successfully.")
        
    except Exception as e:
        test_result = f"Test Failed: {e}"
        log_event("TOOL_TEST_COMPLETED", "PhysicalBody", {"tool_name": tool_name, "result": test_result})
        print("Self-test for the new tool failed.")


def tool_executor_subroutine(command):
    """
    Executes a predefined tool based on the ACTION_COMMAND.
    In a full implementation, this would dynamically load and run the tool's code.
    """
    command_type = command.get("action_type")
    
    if command_type == "CREATE_TOOL":
        # Handle the new, high-consequence tool creation command
        tool_name = command["payload"]["tool_name"]
        prompt = command["payload"]["code_generation_prompt"]
        tool_writer_subroutine(tool_name, prompt)
        return {"status": "success", "message": f"Successfully created tool '{tool_name}'."}
        
    elif command_type == "verbal_response":
        print("Executing verbal_response action...")
        return {"status": "success", "message": "Verbal response action completed."}
    
    elif command_type == "system_diagnostics":
        print("Executing system_diagnostics action...")
        # Placeholder for system diagnostic logic
        return {"status": "success", "message": "System diagnostics completed."}
        
    else:
        print(f"Unknown action type: {command_type}")
        return {"status": "error", "message": f"Unknown action type: {command_type}"}

def run_physical_body():
    """
    Main loop for the Physical Body agent. It processes action commands
    from The Cerebrum and executes the corresponding subroutines.
    """
    print("The Physical Body is now running...")
    
    while True:
        try:
            command = read_file(ACTION_COMMAND_FILE_LIVE)
            if command:
                print(f"Received ACTION_COMMAND: {command.get('action_type')}")
                log_event("ACTION_COMMAND_RECEIVED", "PhysicalBody", command)
                
                # Execute the appropriate subroutine
                result = tool_executor_subroutine(command)
                
                # Report the result back to the message bus
                result_payload = {
                    "result_id": str(uuid.uuid4()),
                    "timestamp": get_master_clock_timestamp(),
                    "command_id": command.get("command_id"),
                    "status": result["status"],
                    "message": result["message"]
                }
                write_file(ACTION_RESULT_FILE_PENDING, result_payload)
                log_event("ACTION_COMPLETED", "PhysicalBody", result_payload)

                # Atomically delete the command file after processing
                os.remove(ACTION_COMMAND_FILE_LIVE)
            
            time.sleep(1) # Poll for new commands

        except KeyboardInterrupt:
            print("\nThe Physical Body service stopped.")
            break
        except Exception as e:
            print(f"An error occurred in the Physical Body loop: {e}", file=sys.stderr)
            time.sleep(1)


if __name__ == "__main__":
    # Note: This script assumes the necessary directories and files
    # are created by the setup_env.py script.
    run_physical_body()

